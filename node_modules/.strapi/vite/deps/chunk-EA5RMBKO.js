import {
  useRegenerateTokenMutation
} from "./chunk-VKUMSOUE.js";
import {
  BackButton,
  ConfirmDialog,
  ContentBox,
  Layouts,
  useClipboard
} from "./chunk-VPGTOWWY.js";
import {
  useAPIErrorHandler,
  useNotification,
  useTracking
} from "./chunk-J6CPTLIL.js";
import {
  locale_exports
} from "./chunk-EJZYDBQI.js";
import {
  addDays,
  format
} from "./chunk-TLRJLUXM.js";
import {
  Button,
  Dialog,
  Field,
  Flex,
  IconButton,
  SingleSelect,
  SingleSelectOption,
  TextInput,
  Textarea,
  Typography,
  useIntl
} from "./chunk-4GWSCROJ.js";
import {
  ForwardRef$2t,
  ForwardRef$3F,
  ForwardRef$4p,
  ForwardRef$51
} from "./chunk-DCJFY6LG.js";
import {
  require_jsx_runtime
} from "./chunk-QBLEIVF7.js";
import {
  require_react
} from "./chunk-BCGHH3YY.js";
import {
  __toESM
} from "./chunk-WGAPYIUP.js";

// node_modules/@strapi/plugin-documentation/node_modules/@strapi/admin/dist/admin/TokenTypeSelect-B6ImfDRL.mjs
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var React = __toESM(require_react(), 1);
var Regenerate = ({ onRegenerate, url }) => {
  const { formatMessage } = useIntl();
  const [showConfirmDialog, setShowConfirmDialog] = React.useState(false);
  const [isLoadingConfirmation, setIsLoadingConfirmation] = React.useState(false);
  const { toggleNotification } = useNotification();
  const { _unstableFormatAPIError: formatAPIError } = useAPIErrorHandler();
  const [regenerateToken] = useRegenerateTokenMutation();
  const regenerateData = async () => {
    try {
      const res = await regenerateToken(url);
      if ("error" in res) {
        toggleNotification({
          type: "danger",
          message: formatAPIError(res.error)
        });
        return;
      }
      if (onRegenerate) {
        onRegenerate(res.data.accessKey);
      }
    } catch (error) {
      toggleNotification({
        type: "danger",
        message: formatMessage({
          id: "notification.error",
          defaultMessage: "Something went wrong"
        })
      });
    } finally {
      setIsLoadingConfirmation(false);
    }
  };
  const handleConfirmRegeneration = async () => {
    regenerateData();
    setShowConfirmDialog(false);
  };
  return (0, import_jsx_runtime.jsxs)(Dialog.Root, { open: showConfirmDialog, onOpenChange: setShowConfirmDialog, children: [
    (0, import_jsx_runtime.jsx)(Dialog.Trigger, { children: (0, import_jsx_runtime.jsx)(
      Button,
      {
        startIcon: (0, import_jsx_runtime.jsx)(ForwardRef$51, {}),
        type: "button",
        size: "S",
        variant: "tertiary",
        onClick: () => setShowConfirmDialog(true),
        name: "regenerate",
        children: formatMessage({
          id: "Settings.tokens.regenerate",
          defaultMessage: "Regenerate"
        })
      }
    ) }),
    (0, import_jsx_runtime.jsx)(
      ConfirmDialog,
      {
        title: formatMessage({
          id: "Settings.tokens.RegenerateDialog.title",
          defaultMessage: "Regenerate token"
        }),
        endAction: (0, import_jsx_runtime.jsx)(
          Button,
          {
            startIcon: (0, import_jsx_runtime.jsx)(ForwardRef$51, {}),
            loading: isLoadingConfirmation,
            onClick: handleConfirmRegeneration,
            children: formatMessage({
              id: "Settings.tokens.Button.regenerate",
              defaultMessage: "Regenerate"
            })
          }
        ),
        children: formatMessage({
          id: "Settings.tokens.popUpWarning.message",
          defaultMessage: "Are you sure you want to regenerate this token?"
        })
      }
    )
  ] });
};
var FormHead = ({
  title,
  token,
  setToken,
  canEditInputs,
  canRegenerate,
  isSubmitting,
  regenerateUrl
}) => {
  const { formatMessage } = useIntl();
  const handleRegenerate = (newKey) => {
    setToken({
      ...token,
      accessKey: newKey
    });
  };
  return (0, import_jsx_runtime.jsx)(
    Layouts.Header,
    {
      title: (token == null ? void 0 : token.name) || formatMessage(title),
      primaryAction: canEditInputs ? (0, import_jsx_runtime.jsxs)(Flex, { gap: 2, children: [
        canRegenerate && (token == null ? void 0 : token.id) && (0, import_jsx_runtime.jsx)(
          Regenerate,
          {
            onRegenerate: handleRegenerate,
            url: `${regenerateUrl}${(token == null ? void 0 : token.id) ?? ""}`
          }
        ),
        (0, import_jsx_runtime.jsx)(
          Button,
          {
            disabled: isSubmitting,
            loading: isSubmitting,
            startIcon: (0, import_jsx_runtime.jsx)(ForwardRef$4p, {}),
            type: "submit",
            size: "S",
            children: formatMessage({
              id: "global.save",
              defaultMessage: "Save"
            })
          }
        )
      ] }) : canRegenerate && (token == null ? void 0 : token.id) && (0, import_jsx_runtime.jsx)(
        Regenerate,
        {
          onRegenerate: handleRegenerate,
          url: `${regenerateUrl}${(token == null ? void 0 : token.id) ?? ""}`
        }
      ),
      navigationAction: (0, import_jsx_runtime.jsx)(BackButton, {}),
      ellipsis: true
    }
  );
};
var TokenBox = ({ token, tokenType }) => {
  const { formatMessage } = useIntl();
  const { toggleNotification } = useNotification();
  const { trackUsage } = useTracking();
  const { copy } = useClipboard();
  const handleClick = (token2) => async () => {
    if (token2) {
      const didCopy = await copy(token2);
      if (didCopy) {
        trackUsage("didCopyTokenKey", {
          tokenType
        });
        toggleNotification({
          type: "success",
          message: formatMessage({ id: "Settings.tokens.notification.copied" })
        });
      }
    }
  };
  return (0, import_jsx_runtime.jsx)(
    ContentBox,
    {
      endAction: token && (0, import_jsx_runtime.jsx)("span", { style: { alignSelf: "start" }, children: (0, import_jsx_runtime.jsx)(
        IconButton,
        {
          label: formatMessage({
            id: "app.component.CopyToClipboard.label",
            defaultMessage: "Copy to clipboard"
          }),
          onClick: handleClick(token),
          variant: "ghost",
          style: { padding: 0, height: "1.6rem" },
          children: (0, import_jsx_runtime.jsx)(ForwardRef$3F, {})
        }
      ) }),
      title: token || formatMessage({
        id: "Settings.tokens.copy.editTitle",
        defaultMessage: "This token isn’t accessible anymore."
      }),
      subtitle: token ? formatMessage({
        id: "Settings.tokens.copy.lastWarning",
        defaultMessage: "Make sure to copy this token, you won’t be able to see it again!"
      }) : formatMessage({
        id: "Settings.tokens.copy.editMessage",
        defaultMessage: "For security reasons, you can only see your token once."
      }),
      icon: (0, import_jsx_runtime.jsx)(ForwardRef$2t, {}),
      iconBackground: "neutral100"
    }
  );
};
var getDateFnsLocaleName = (locale) => {
  if (Object.keys(locale_exports).includes(locale)) {
    return locale;
  }
  return "enUS";
};
var getDateOfExpiration = (createdAt, duration, language = "en") => {
  if (duration && typeof duration === "number") {
    const durationInDays = duration / 24 / 60 / 60 / 1e3;
    return format(addDays(new Date(createdAt), durationInDays), "PPP", {
      locale: locale_exports[getDateFnsLocaleName(language)]
    });
  }
  return "Unlimited";
};
var isErrorMessageMessageDescriptor = (message) => {
  return typeof message === "object" && message !== null && "id" in message;
};
var LifeSpanInput = ({
  token,
  error,
  value,
  onChange,
  isCreating
}) => {
  const { formatMessage } = useIntl();
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [
    (0, import_jsx_runtime.jsxs)(
      Field.Root,
      {
        error: error ? formatMessage(
          isErrorMessageMessageDescriptor(error) ? error : { id: error, defaultMessage: error }
        ) : void 0,
        name: "lifespan",
        required: true,
        children: [
          (0, import_jsx_runtime.jsx)(Field.Label, { children: formatMessage({
            id: "Settings.tokens.form.duration",
            defaultMessage: "Token duration"
          }) }),
          (0, import_jsx_runtime.jsxs)(
            SingleSelect,
            {
              value,
              onChange: (value2) => {
                onChange({ target: { name: "lifespan", value: value2 } });
              },
              disabled: !isCreating,
              placeholder: "Select",
              children: [
                (0, import_jsx_runtime.jsx)(SingleSelectOption, { value: "604800000", children: formatMessage({
                  id: "Settings.tokens.duration.7-days",
                  defaultMessage: "7 days"
                }) }),
                (0, import_jsx_runtime.jsx)(SingleSelectOption, { value: "2592000000", children: formatMessage({
                  id: "Settings.tokens.duration.30-days",
                  defaultMessage: "30 days"
                }) }),
                (0, import_jsx_runtime.jsx)(SingleSelectOption, { value: "7776000000", children: formatMessage({
                  id: "Settings.tokens.duration.90-days",
                  defaultMessage: "90 days"
                }) }),
                (0, import_jsx_runtime.jsx)(SingleSelectOption, { value: "0", children: formatMessage({
                  id: "Settings.tokens.duration.unlimited",
                  defaultMessage: "Unlimited"
                }) })
              ]
            }
          ),
          (0, import_jsx_runtime.jsx)(Field.Error, {})
        ]
      }
    ),
    (0, import_jsx_runtime.jsx)(Typography, { variant: "pi", textColor: "neutral600", children: !isCreating && `${formatMessage({
      id: "Settings.tokens.duration.expiration-date",
      defaultMessage: "Expiration date"
      // @ts-expect-error – TODO: fix this.
    })}: ${getDateOfExpiration(token == null ? void 0 : token.createdAt, parseInt(value ?? "", 10))}` })
  ] });
};
var TokenDescription = ({
  error,
  value,
  onChange,
  canEditInputs
}) => {
  const { formatMessage } = useIntl();
  return (0, import_jsx_runtime.jsxs)(
    Field.Root,
    {
      name: "description",
      error: error ? formatMessage(
        isErrorMessageMessageDescriptor(error) ? error : {
          id: error,
          defaultMessage: error
        }
      ) : void 0,
      children: [
        (0, import_jsx_runtime.jsx)(Field.Label, { children: formatMessage({
          id: "Settings.tokens.form.description",
          defaultMessage: "Description"
        }) }),
        (0, import_jsx_runtime.jsx)(Textarea, { onChange, disabled: !canEditInputs, value }),
        (0, import_jsx_runtime.jsx)(Field.Error, {})
      ]
    }
  );
};
var TokenName = ({ error, value, onChange, canEditInputs }) => {
  const { formatMessage } = useIntl();
  return (0, import_jsx_runtime.jsxs)(
    Field.Root,
    {
      name: "name",
      error: error ? formatMessage(
        isErrorMessageMessageDescriptor(error) ? error : { id: error, defaultMessage: error }
      ) : void 0,
      required: true,
      children: [
        (0, import_jsx_runtime.jsx)(Field.Label, { children: formatMessage({
          id: "Settings.tokens.form.name",
          defaultMessage: "Name"
        }) }),
        (0, import_jsx_runtime.jsx)(TextInput, { onChange, value, disabled: !canEditInputs }),
        (0, import_jsx_runtime.jsx)(Field.Error, {})
      ]
    }
  );
};
var TokenTypeSelect = ({
  name = "type",
  error,
  value,
  onChange,
  canEditInputs,
  options = [],
  label
}) => {
  const { formatMessage } = useIntl();
  return (0, import_jsx_runtime.jsxs)(
    Field.Root,
    {
      error: error ? formatMessage(
        isErrorMessageMessageDescriptor(error) ? error : { id: error, defaultMessage: error }
      ) : void 0,
      name,
      required: true,
      children: [
        (0, import_jsx_runtime.jsx)(Field.Label, { children: formatMessage({
          id: label.id,
          defaultMessage: label.defaultMessage
        }) }),
        (0, import_jsx_runtime.jsx)(
          SingleSelect,
          {
            value,
            onChange,
            placeholder: "Select",
            disabled: !canEditInputs,
            children: options && options.map(({ value: value2, label: label2 }) => (0, import_jsx_runtime.jsx)(SingleSelectOption, { value: value2, children: formatMessage(label2) }, value2))
          }
        ),
        (0, import_jsx_runtime.jsx)(Field.Error, {})
      ]
    }
  );
};

export {
  FormHead,
  TokenBox,
  LifeSpanInput,
  TokenDescription,
  TokenName,
  TokenTypeSelect
};
//# sourceMappingURL=chunk-EA5RMBKO.js.map
